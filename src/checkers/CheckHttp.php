<?php

namespace Drachenkatze\ZoneChecker\Checkers;

use GuzzleHttp\Client;

class CheckHttp extends AbstractChecker
{
    /**
     * @var array
     */
    private $urls = ["/"];

    /**
     * @var bool
     */
    private $http = true;

    /**
     * @var bool
     */
    private $https = false;

    /**
     * @var bool
     */
    private $http_should_redirect_to_https = false;

    /**
     * @var array
     */
    private $status_codes = [200];

    /**
     * @var array
     */
    private $content_should_contain = [];

    /**
     * @var array
     */
    private $content_should_not_contain = [];

    private $check_certificate = true;

    private $override_port_ssl = null;

    private $override_port = null;

    public static function canHandle(string $checkerType)
    {
        if ($checkerType == "check_http") {
            return true;
        }

        return false;
    }

    public function setConfig(array $config)
    {
        parent::setConfig($config); // TODO: Change the autogenerated stub

        if (array_key_exists("urls", $config)) {
            $this->urls = $config["urls"];
        }

        if (array_key_exists("https", $config)) {
            $this->https = (bool)$config["https"];
        }
        if (array_key_exists("http", $config)) {
            $this->http = (bool)$config["http"];
        }

        if (array_key_exists("http_should_redirect_to_https", $config)) {
            $this->http_should_redirect_to_https = (bool)$config["http_should_redirect_to_https"];
        }

        if (array_key_exists("status_codes", $config)) {
            $this->status_codes = $config["status_codes"];
        }

        if (array_key_exists("content_should_not_contain", $config)) {
            $this->content_should_not_contain = $config["content_should_not_contain"];
        }

        if (array_key_exists("content_should_contain", $config)) {
            $this->content_should_contain = $config["content_should_contain"];
        }

        if (array_key_exists("check_certificate", $config)) {
            $this->check_certificate = $config["check_certificate"];
        }

        if (array_key_exists("override_port", $config)) {
            $this->override_port = $config["override_port"];
        }

        if (array_key_exists("override_port_ssl", $config)) {
            $this->override_port_ssl = $config["override_port_ssl"];
        }
    }


    public function check()
    {


        foreach ($this->urls as $url) {

            if ($this->resourceRecord->getType() == "A") {
                $this->doChecks($url, true);
            }

            if ($this->resourceRecord->getType() == "AAAA") {
                $this->doChecks($url, false);
            }

            if ($this->resourceRecord->getType() == "CNAME") {
                $results = dns_get_record($this->getCNameFQDN());

                $hadV6 = false;
                $hadV4 = false;
                foreach ($results as $result) {
                    if ($result["type"] == "A" && !$hadV4) {
                        $this->doChecks($url, true);
                        $hadV4 = true;
                    }

                    if ($result["type"] == "AAAA" && !$hadV6) {
                        $this->doChecks($url, false);
                        $hadV6 = true;
                    }
                }
            }


        }
    }

    private function doChecks($url, $ipv4)
    {
        $finalName = $this->getFQDN();

        if ($this->http_should_redirect_to_https) {
            try {
                $this->checkHttpsRedirect($finalName, $url, $ipv4);
            } catch (\Exception $e) {
                $this->logError("Check for http redirect to https returned " . $e->getMessage());
            }
        }

        if ($this->http) {
            try {
                $this->checkRequest($finalName, $url, false, $ipv4);
            } catch (\Exception $e) {
                $this->logError("Check for http returned " . $e->getMessage());
            }
        }

        if ($this->https) {
            try {
                $this->checkRequest($finalName, $url, true, $ipv4);
            } catch (\Exception $e) {
                $this->logError("Check for https returned " . $e->getMessage());
            }
        }
    }

    private function checkRequest($domain, $url, $secure, $ipv4)
    {
        $protocol = "http://";
        if ($secure) {
            $protocol = "https://";
        }

        $fullUrl = $protocol . $domain . $url;

        if ($secure && $this->override_port_ssl) {
            $fullUrl = $protocol . $domain . ":" . $this->override_port_ssl . $url;
        }

        if (!$secure && $this->override_port) {
            $fullUrl = $protocol . $domain . ":" . $this->override_port . $url;
        }
        $client = new Client();

        $options = ["http_errors" => false];

        if ($ipv4) {
            $options['force_ip_resolve'] = "v4";
            $viaString = "via IPv4";
        } else {
            $options['force_ip_resolve'] = "v6";
            $viaString = "via IPv6";
        }

        if (!$this->check_certificate) {
            $options["verify"] = false;
        }

        $response = $client->request('GET', $fullUrl, $options);

        if (count($this->status_codes) > 0 && !in_array($response->getStatusCode(), $this->status_codes)) {
            $allowedCodes = join(",", $this->status_codes);
            var_dump($response->getBody()->getContents());
            var_dump($response->getHeaders());
            $this->logError("Status code for {$fullUrl} was {$response->getStatusCode()} which does not match the allowed codes of {$allowedCodes} {$viaString}");
            return;
        }

        $responseBody = $response->getBody()->getContents();

        if (count($this->content_should_contain) > 0) {
            foreach ($this->content_should_contain as $str) {
                if (stripos($responseBody, $str) === false) {
                    $this->logError("String {$str} was not found in the response for {$fullUrl} {$viaString}");
                }
            }
        }

        if (count($this->content_should_not_contain) > 0) {
            foreach ($this->content_should_not_contain as $str) {


                if (stripos($responseBody, $str) !== false) {
                    $this->logError("String {$str} was found in the response for {$fullUrl} but should not be there {$viaString}");
                }
            }
        }

    }

    private function checkHttpsRedirect($domain, $url, $ipv4)
    {

        $options = ['allow_redirects' => false, "http_errors" => false];

        if ($ipv4) {
            $options['force_ip_resolve'] = "v4";
        } else {
            $options['force_ip_resolve'] = "v6";
        }

        $client = new Client();
        $response = $client->request('GET', "http://" . $domain . $url, $options);

        if (!in_array($response->getStatusCode(), [301, 302])) {
            $this->logError("Status code for {$domain}{$url} was {$response->getStatusCode()} which is not a redirect.");
            return;
        }

        if (!$response->hasHeader("Location")) {
            $this->logError("Redirect status code was found but no Location header was returned");
            return;
        }

        $locationHeader = $response->getHeader("Location");
        if (count($locationHeader) != 1) {
            $this->logError("Multiple location headers were returned");
            return;
        }

        if ($locationHeader[0] != "https://" . $domain . $url) {
            $this->logError("Expected http://{$domain}{$url} to redirect to https://{$domain}{$url} but found {$locationHeader[0]}");
            return;
        }
    }
}